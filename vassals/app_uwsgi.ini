[uwsgi]

# 访问端口
http = 127.0.0.1:8081

# 在app加载前切换到当前目录， 指定运行目录
chdir = /Users/micllo/Documents/works/GitHub/pythonSelenium

# flask程序的启动文件
wsgi-file = %(chdir)/api/server.py

# 程序内启用Flask实例对象的变量名
callable = flask_app

# 启动2个工作进程，生成指定数目的 worker 进程
processes = 2

# 每个进程下运行的线程数
threads = 2

# 启动主进程，来管理其他进程，其它的uwsgi进程都是这个master进程的子进程，如果kill这个master进程，相当于重启所有的uwsgi进程。
master = true

# 记录日志
logto = %(chdir)/Logs/uwsgi_log.log
# 设置最大日志文件大小
log-maxsize = 5000000

# 指定pid文件
pidfile = %(chdir)/Logs/uwsgi_pid.pid

#【 解决 APSchedler 任务不能执行的问题 】
# 允许用内嵌的语言启动线程。这将允许你在app程序中产生一个子线程
enable-threads = true
;preload = True

# 使用虚拟环境
home = %(chdir)/venv


# 以守护进程运行，并将日志打到指定的日志(问题：会导致sytemctl启动时多次重启而导致启动失败)
;daemonize = %(chdir)/Logs/uwsgi_log.log

# 在每个worker而不是master中加载应用
#lazy-apps=true

# 指定socket文件，也可以指定为127.0.0.1:9000，这样就会监听到网络套接字
;socket = /test/myapp.sock

# 设置socket的监听队列大小
#listen = 1024


##################################################


# 单个 执行命令
# uwsgi --ini /Users/micllo/Documents/works/GitHub/pythonSelenium/vassals/app_uwsgi.ini

# 批量 执行命令 emperor：
# 1.批量启动 vassals 目录下的 uwsgi 项目
# 2.监视 vassals 目录下的 ini 配置文件
# --uid centos ：让 centos 用户 有权限管理
# --gid centos ：让 centos 组 有权限管理
#uwsgi --master --emperor /Users/micllo/Documents/works/GitHub/pythonSelenium/vassals --die-on-term --logto /Users/micllo/Documents/works/GitHub/pythonSelenium/Logs/emperor.log

# 查看 uwsgi 进程ID
# ps -ef | grep -v "grep" | grep uwsgi

# 杀死 uwsgi 进程
# ps aux | grep -v "grep" | grep uwsgi | awk '{print $2}' | xargs kill -9